<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>3D Game of Life â€“ Snillet Edition</title>
  <style>
    body { margin: 0; overflow: hidden; background: black; font-family: monospace; color: #00ffcc; }
    canvas { display: block; }
    #scrollText {
      position: absolute;
      top: 90%;
      left: 100%;
      white-space: nowrap;
      font-size: 1.2em;
      animation: scroll 30s linear infinite;
    }
    @keyframes scroll {
      0% { left: 100%; }
      100% { left: -100%; }
    }
  </style>
</head>
<body>
<canvas id="glcanvas"></canvas>
<div id="scrollText">3D Game of Life â€“ Snillet remix ðŸŽ‡ðŸ§¬ðŸŒŒ</div>
<audio autoplay loop>
  <source src="https://cdn.pixabay.com/download/audio/2022/10/18/audio_230fc452a9.mp3?filename=dreamy-groove-124302.mp3" type="audio/mpeg">
</audio>
<script type="module">
import * as THREE from 'https://cdn.skypack.dev/three@0.152.2';

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(50, 50, 100);
camera.lookAt(25, 25, 25);

const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('glcanvas'), antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

const gridSize = 30;
const spacing = 2;
let grid = Array.from({ length: gridSize }, () =>
  Array.from({ length: gridSize }, () =>
    Array.from({ length: gridSize }, () => Math.random() > 0.9 ? 1 : 0)
  )
);

const cubes = [];
const geometry = new THREE.BoxGeometry(1.5, 1.5, 1.5);

for (let z = 0; z < gridSize; z++) {
  for (let y = 0; y < gridSize; y++) {
    for (let x = 0; x < gridSize; x++) {
      const material = new THREE.MeshStandardMaterial({ color: 0x00ffff, transparent: true, opacity: 0 });
      const cube = new THREE.Mesh(geometry, material);
      cube.position.set(x * spacing, y * spacing, z * spacing);
      scene.add(cube);
      cubes.push(cube);
    }
  }
}

const light = new THREE.PointLight(0xffffff, 1.5);
light.position.set(100, 100, 100);
scene.add(light);

function countNeighbors(x, y, z) {
  let sum = 0;
  for (let dz = -1; dz <= 1; dz++) {
    for (let dy = -1; dy <= 1; dy++) {
      for (let dx = -1; dx <= 1; dx++) {
        if (dx === 0 && dy === 0 && dz === 0) continue;
        const nx = (x + dx + gridSize) % gridSize;
        const ny = (y + dy + gridSize) % gridSize;
        const nz = (z + dz + gridSize) % gridSize;
        sum += grid[nz][ny][nx];
      }
    }
  }
  return sum;
}

function updateGrid() {
  const next = Array.from({ length: gridSize }, () =>
    Array.from({ length: gridSize }, () => Array(gridSize).fill(0))
  );
  for (let z = 0; z < gridSize; z++) {
    for (let y = 0; y < gridSize; y++) {
      for (let x = 0; x < gridSize; x++) {
        const state = grid[z][y][x];
        const neighbors = countNeighbors(x, y, z);
        next[z][y][x] = (state === 1 && (neighbors === 5 || neighbors === 6)) || (state === 0 && neighbors === 5) ? 1 : 0;
      }
    }
  }
  grid = next;
}

function renderGrid() {
  let i = 0;
  for (let z = 0; z < gridSize; z++) {
    for (let y = 0; y < gridSize; y++) {
      for (let x = 0; x < gridSize; x++) {
        cubes[i].material.opacity =
