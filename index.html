<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Fraktalgenerator</title>
  <style>
    body { margin: 0; overflow: hidden; background: black; }
    canvas { display: block; width: 100vw; height: 100vh; }
  </style>
</head>
<body>
<canvas id="glcanvas"></canvas>
<script>
const vertexShaderSource = `
  attribute vec2 a_position;
  void main() {
    gl_Position = vec4(a_position, 0, 1);
  }
`;

const fragmentShaderSource = `
  precision highp float;

  uniform vec2 u_resolution;
  uniform float u_time;
  uniform int u_type; // 0 = Mandelbrot, 1 = Julia
  uniform vec2 u_c;
  uniform float u_zoom;

  int mandelbrot(vec2 z) {
    vec2 c = z;
    int iter;
    for (iter = 0; iter < 256; iter++) {
      float x = (z.x * z.x - z.y * z.y) + c.x;
      float y = (2.0 * z.x * z.y) + c.y;
      if (x*x + y*y > 4.0) break;
      z = vec2(x, y);
    }
    return iter;
  }

  int julia(vec2 z, vec2 c) {
    int iter;
    for (iter = 0; iter < 256; iter++) {
      float x = (z.x * z.x - z.y * z.y) + c.x;
      float y = (2.0 * z.x * z.y) + c.y;
      if (x*x + y*y > 4.0) break;
      z = vec2(x, y);
    }
    return iter;
  }

  void main() {
    vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution.xy) / u_resolution.y;
    uv *= u_zoom;
    int n = u_type == 0 ? mandelbrot(uv) : julia(uv, u_c);
    float color = float(n) / 256.0;
    gl_FragColor = vec4(vec3(sin(color * 6.2831), cos(color * 4.0), color), 1.0);
  }
`;

function createShader(gl, type, source) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  return shader;
}

function createProgram(gl, vertexShader, fragmentShader) {
  const program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  return program;
}

function main() {
  const canvas = document.getElementById("glcanvas");
  const gl = canvas.getContext("webgl");
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  const vShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
  const fShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
  const program = createProgram(gl, vShader, fShader);

  const positionAttribute = gl.getAttribLocation(program, "a_position");
  const buffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.bufferData(
    gl.ARRAY_BUFFER,
    new Float32Array([
      -1, -1, 1, -1, -1, 1,
      -1, 1, 1, -1, 1, 1
    ]),
    gl.STATIC_DRAW
  );

  gl.useProgram(program);
  gl.enableVertexAttribArray(positionAttribute);
  gl.vertexAttribPointer(positionAttribute, 2, gl.FLOAT, false, 0, 0);

  const resLoc = gl.getUniformLocation(program, "u_resolution");
  const timeLoc = gl.getUniformLocation(program, "u_time");
  const typeLoc = gl.getUniformLocation(program, "u_type");
  const cLoc = gl.getUniformLocation(program, "u_c");
  const zoomLoc = gl.getUniformLocation(program, "u_zoom");

  const type = Math.random() < 0.5 ? 0 : 1;
  const c = [Math.random() * 2 - 1, Math.random() * 2 - 1];
  const zoom = 0.5 + Math.random();

  function render(t) {
    gl.viewport(0, 0, canvas.width, canvas.height);
    gl.uniform2f(resLoc, canvas.width, canvas.height);
    gl.uniform1f(timeLoc, t * 0.001);
    gl.uniform1i(typeLoc, type);
    gl.uniform2f(cLoc, c[0], c[1]);
    gl.uniform1f(zoomLoc, zoom);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    requestAnimationFrame(render);
  }

  requestAnimationFrame(render);
}

main();
</script>
</body>
</html>
